#!/usr/bin/perl

=head1 Program

predict_convert.pl  --  convert the raw gene predictions to gff, cds, and protein format.

=head1 Description

This program convert the raw result from gene predicting softwares to other 
usually used formats, it is designed to be a universal gene format converter.

Sometimes, the predicting software runs very slowly with large sequence,such as genscan,
 we should cut the sequence into smaller fragments, and assign the a
fragment ID like "seq1_500_1000", where "seq1" is the origninal seqence ID, "500" 
is the starting position, "1000" is the ending position. Then we can predict genes
on each smaller fragments, and use the option --backcoor to trace back the coordinate onto 
the original sequence.

The output location files include table format, gff3 format and psl format. The
output sequence files include CDS file, protein file, exon DNA file, and exon 
protein file, as well as the intron dna file.  You can also use getGene.pl
to get these types of sequences.

There are two options to control gene ID format. The --nametag option will just add a prefix tag 
before the original gene ID; The --finalname option will rename all the genes on the whole genome
level.

There are 4 options to control gene quality. The --perfectgene, --miniseq, --minicds, --checkcds.
In default settings, they are all closed. You can choose one or more of them as your need.

For the glean result, it must be sorted of gene order before using this program,
otherwise the gene id will not in sequential order along the chromosome.

At current, this program can accept result of bgf, fgenesh, genscan, glean, genemark, glimmer.

The gene data structure is stored in %all, there is an exmple for both genes on both strands
after the end of this program, generated by "print Dumper \%all". The block order for both genes
is from the first exon to the last exon, and from the start of exon to the end of exon.

=head1 Contact & Version

  Author: Fan Wei, fanw@genomics.org.cn
  Version: 2.0,  Date: 2007-8-5

=head1 Command-line Option
  
  % predict_convert.pl  <predict_result>  <original_seqence>
  
  --predict          specify the name of predicting software, bgf, genscan
  --backcoor         trace back the coordinate onto the original sequence  
  
  --nametag <str>    add a prefix tag for gene name on individual sequence level
  --finalname <str>  make final gene name with prefix tag in genome level
  
  --perfectgene      only keep complete genes, remove partial genes
  --miniseq <num>    remove genes predicted on seqeunce shorter than miniseq (default 0 bp)
  --minicds <num>    remove genes which cds length is smaller than minicds (default 0 bp )
  --checkcds         remove genes which is not correct gene model by post-checking on CDS sequence
  --filter_ns        filter CDS which contains non ACGT characters

  --log              transfer STDERR information to a log file
  --verbose          output the running progress information
  --help             output help information

=head1 Usage Exmples

perl ../bin/predict_convert.pl --predict bgf --perfect --checkcds --final BGIBMBA --log --verbose silkworm_premasked.bgf  kaikoall_build2.rechained.fasta &
perl ../bin/predict_convert.pl --predict glean --perfect --checkcds --final BGIBMGA --log --verbose silkworm_glean-dp.gff  kaikoall_build2.rechained.fasta &
perl ../bin/predict_convert.pl --predict genescan --perfect --checkcds --final BGIBMSA --log --verbose --back silkworm_premasked.genescan  kaikoall_build2.rechained.fasta &
perl ../bin/predict_convert.pl --predict glimmer  --final BSP --log --verbose PLASMID.fasta.glimmer3 ../../00.genome-sequence/PLASMID.fasta

=cut

use strict;
use Getopt::Long;
use Data::Dumper;
use FindBin qw($Bin $Script);

my ($Predict_prog,$Back_coor,$Name_tag,$Final_name,$Perfect_gene);
my ($Mini_seq,$Mini_cds,$Check_cds,$Filter_Ns,$Log,$Verbose,$Help);
GetOptions(
	"predict:s" => \$Predict_prog,
	"backcoor" => \$Back_coor,
	"nametag:s" => \$Name_tag,
	"finalname:s"=>\$Final_name,
	"perfectgene" => \$Perfect_gene,
	"miniseq:n" => \$Mini_seq,
	"minicds:n" => \$Mini_cds,
	"checkcds"=>\$Check_cds,
	"filter_ns"=>\$Filter_Ns,
	"log"=>\$Log,
	"verbose"=>\$Verbose,
	"help"=>\$Help
);
$Name_tag &&= $Name_tag."_";
$Mini_seq ||= 0;
$Mini_cds ||= 0;
die `pod2text $0` if (@ARGV == 0 || !$Predict_prog || $Help);

my $predict_file = shift;
my $sequence_file = shift;


##codon table 1 and codon table 11， for both eukayrote and prokaryote
my %Translate = (
	'GCA' => 'A', 'GCC' => 'A', 'GCG' => 'A', 'GCT' => 'A',                               # Alanine
	'TGC' => 'C', 'TGT' => 'C',                                                           # Cysteine
	'GAC' => 'D', 'GAT' => 'D',                                                           # Aspartic Acid
	'GAA' => 'E', 'GAG' => 'E',                                                           # Glutamic Acid
	'TTC' => 'F', 'TTT' => 'F',                                                           # Phenylalanine
	'GGA' => 'G', 'GGC' => 'G', 'GGG' => 'G', 'GGT' => 'G',                               # Glycine
	'CAC' => 'H', 'CAT' => 'H',                                                           # Histidine
	'ATA' => 'I', 'ATC' => 'I', 'ATT' => 'I',                                             # Isoleucine
	'AAA' => 'K', 'AAG' => 'K',                                                           # Lysine
	'CTA' => 'L', 'CTC' => 'L', 'CTG' => 'L', 'CTT' => 'L', 'TTA' => 'L', 'TTG' => 'L',   # Leucine
	'ATG' => 'M',                                                                         # Methionine
	'AAC' => 'N', 'AAT' => 'N',                                                           # Asparagine
	'CCA' => 'P', 'CCC' => 'P', 'CCG' => 'P', 'CCT' => 'P',                               # Proline
	'CAA' => 'Q', 'CAG' => 'Q',                                                           # Glutamine
	'CGA' => 'R', 'CGC' => 'R', 'CGG' => 'R', 'CGT' => 'R', 'AGA' => 'R', 'AGG' => 'R',   # Arginine
	'TCA' => 'S', 'TCC' => 'S', 'TCG' => 'S', 'TCT' => 'S', 'AGC' => 'S', 'AGT' => 'S',   # Serine
	'ACA' => 'T', 'ACC' => 'T', 'ACG' => 'T', 'ACT' => 'T',                               # Threonine
	'GTA' => 'V', 'GTC' => 'V', 'GTG' => 'V', 'GTT' => 'V',                               # Valine
	'TGG' => 'W',                                                                         # Tryptophan
	'TAC' => 'Y', 'TAT' => 'Y',                                                           # Tyrosine
	'TAA' => 'U', 'TAG' => 'U', 'TGA' => 'U',                                             # Stop
);


my $table_file = $predict_file.".tab";
my $gff_file = $predict_file.".gff";
my $psl_file = $predict_file.".psl";
my $cds_file = $predict_file.".cds";
my $prot_file = $predict_file.".pep";
my $exon_dna_file = $predict_file.".exon.dna";
my $exon_prot_file = $predict_file.".exon.pep";
my $intron_dna_file = $predict_file.".intron.dna";
my $log_file = $predict_file.".log";

$Log ? open(LOG, ">$log_file") : (*LOG = *STDERR);

my %all; ##store the main data
my %seq_len; ##store sequence length
my ($num_multi,$num_single,$num_part,$small_cds_num) = (0,0,0,0); ## store gene number of each type

##reading and parsing the prediction file
read_fgenesh() if($Predict_prog eq "fgenesh");
read_bgf() if($Predict_prog eq "bgf");
read_genescan() if($Predict_prog eq "genscan");
read_glean() if($Predict_prog eq "glean");
read_glimmer() if($Predict_prog eq "glimmer");
read_genemark() if($Predict_prog eq "genemark");
print LOG "\nRead $Predict_prog raw result file\n\n" if ($Verbose);



back_coor() if($Back_coor); ## trace coordinate back to original sequence

#print Dumper \%all;

check_redundance(); ## output the checking result to STDERR 


##remove un-wanted genes
perfect_gene() if($Perfect_gene);  ## check the gene type feture

cds_cutoff() if($Mini_cds);

##注意：序列上有问题的基因已经归类于paritial genes
check_cds() if($Check_cds);        ## check cds sequence

filter_Ns() if($Filter_Ns);

#print Dumper \%all;


##make genome wide gene ID
final_name() if($Final_name);

##add "_TA" to the end of geneID for eukaryote species
modify_geneID() if($Predict_prog ne "genemark" && $Predict_prog ne "glimmer");



## output statistic numbers
print LOG "\n\nStatistic of gene numbers:\n" if($Verbose);

print LOG "\nNote that the genes marked by checkcds are assigned to parital genes \n" if($Verbose);

print LOG "\n  [total genes] = [multi-exon genes] + [singl-exon genes] + [partial genes]\n" if($Verbose);
print LOG "  [perfect genes] = [multi-exon genes] + [singl-exon genes]\n" if($Verbose);
print LOG "  [final genes] = [multi-exon genes] + [singl-exon genes] - [small-cds genes]\n" if($Verbose);

print LOG "\n  total genes:      ".($num_multi+$num_single+$num_part)."\n" if($Verbose);
print LOG "  multi-exon genes: $num_multi\n" if($Verbose);
print LOG "  singl-exon genes: $num_single\n" if($Verbose);
print LOG "  partial genes:    $num_part\n" if($Verbose);
print LOG "  perfect genes:    ".($num_multi+$num_single)."\n" if($Verbose);
print LOG "  final genes:      ".($num_multi+$num_single-$small_cds_num)."\n\n" if($Verbose);

#print Dumper \%all;


##creating result files
print LOG "Creating result files:\n" if($Verbose);

creat_table();
print LOG "  the result talbe file created\n" if($Verbose);

creat_psl();
print LOG "  the result psl file created\n" if($Verbose);

creat_gff();
print LOG "  the result gff file created\n" if($Verbose);

creat_sequence() if ($sequence_file);
print LOG "  the result sequence files created\n" if($sequence_file && $Verbose);

print LOG "\nWhole task finished\n\n" if($Verbose);


####################################################
################### Sub Routines ###################
####################################################

sub read_fgenesh{
	$/=" FGENESH 1.1"; 
	my $loop;
	open(PRE,$predict_file) || die("fail to open $predict_file\n");
	<PRE>;
	while (<PRE>) {
		$loop++;
		my $unit = $_;
		chomp $unit;	
		parse_fgenesh(\$unit,\%all) ;
		#print LOG "Parsed sequence $loop\n" if ($Verbose);	
	}
	close(PRE);
	$/="\n";
}

sub read_bgf{
	$/="Program    : BGF";  ##Program    : bgf for old version
	my $loop;
	open(PRE,$predict_file) || die("fail to open $predict_file\n");
	<PRE>;
	while (<PRE>) {
		$loop++;
		my $unit = $_;
		chomp $unit;
		parse_BGF(\$unit,\%all);
		#print LOG "Parsed sequence $loop\n" if ($Verbose);	
	}
	close(PRE);
	$/="\n";
}

sub read_genescan{
	$/="GENSCAN 1.0"; 
	my $loop;
	open(PRE,$predict_file) || die("fail to open $predict_file\n");
	<PRE>;
	while (<PRE>) {
		$loop++;
		my $unit = $_;
		chomp $unit;
		parse_GeneScan(\$unit,\%all);
		#print LOG "Parsed sequence $loop\n" if ($Verbose);	
	}
	close(PRE);
	$/="\n";
}

sub read_glimmer{
	
	my $seq_name;
	open(PRE,$predict_file) || die("fail to open $predict_file\n");
	while (<PRE>) {
		$seq_name = $1 if(/^>(\S+)/);
		if (/^(orf\d+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\S+)/) {
			my (@exon,@orf,@score);
			push @exon, [$2,$3];
			push @orf, [$2,$3];
			push @score, $5;
			
			my $gene_name = $seq_name."_".$1;
			my $strand = $4;
			$strand =~s/[123]$//;
			my $type = "sigle-exon";
			my $promoter = "none";
			my $polyA = "none";
			
			$all{$seq_name}{$gene_name}{strand}=$strand;
			$all{$seq_name}{$gene_name}{type}=$type;
			$all{$seq_name}{$gene_name}{promoter}=$promoter;
			$all{$seq_name}{$gene_name}{exon}=\@exon;
			$all{$seq_name}{$gene_name}{orf}=\@orf;
			$all{$seq_name}{$gene_name}{score}=\@score;
			$all{$seq_name}{$gene_name}{polyA}=$polyA;
			
		}
	}
	close PRE;

	
	get_seq_len();
}

sub read_genemark{

	my $seq_name;
	open(PRE,$predict_file) || die("fail to open $predict_file\n");
	while (<PRE>) {
		$seq_name = $1 if(/^>(\S+)/);
		if (/^\s+(\d+)\s+([+-])\s+(\d+)\s+(\d+)/) {
			my (@exon,@orf,@score);
			my ($start,$end) = ($2 eq '+') ? ($3,$4) : ($4,$3);
			push @exon, [$start,$end];
			push @orf, [$start,$end];
			push @score, '.';
			my $gene_name = $seq_name."_orf".make_mark($1,6);
			my $strand = $2;
			my $type = "sigle-exon";
			my $promoter = "none";
			my $polyA = "none";
			
			$all{$seq_name}{$gene_name}{strand}=$strand;
			$all{$seq_name}{$gene_name}{type}=$type;
			$all{$seq_name}{$gene_name}{promoter}=$promoter;
			$all{$seq_name}{$gene_name}{exon}=\@exon;
			$all{$seq_name}{$gene_name}{orf}=\@orf;
			$all{$seq_name}{$gene_name}{score}=\@score;
			$all{$seq_name}{$gene_name}{polyA}=$polyA;
			
		}
	}
	close PRE;

	#print Dumper \%all;
	get_seq_len();

}

##from number to string, using as mark
sub make_mark{
	my ($num,$len) = @_;
	my $num_len = length($num);
	if ($num_len < $len) {
		my $zero = '0' x ($len - $num_len);
		$num = $zero.$num;
	}
	return $num;
}

sub read_glean{
	$/="\n";
	open(PRE,$predict_file) || die("fail to open $predict_file\n");
	while (<PRE>) {
		s/^\s+//;
		my @t = split(/\t/);
		my $seq_name = $t[0];
		my $gene_name = $seq_name."_".$1 if($t[8] =~ /GenePrediction\s(\S+)$/);
		my $strand = $t[6];
		my $score = $t[5];
		my $phase = $t[7];

		if ($t[2] eq 'mRNA') {
			$all{$seq_name}{$gene_name}{genescore}=$score;
			$all{$seq_name}{$gene_name}{strand}=$strand;
			$all{$seq_name}{$gene_name}{promoter}="none";
			$all{$seq_name}{$gene_name}{polyA}="none";
		}
		if ($t[2] eq 'CDS') {
			my ($exon_start,$exon_end) = ($strand eq '+') ? ($t[3],$t[4]) : ($t[4],$t[3]);
			push @{$all{$seq_name}{$gene_name}{tempexon}}, [$exon_start,$exon_end,$phase,$score];
		}
	}
	close(PRE);

	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my (@exon,@orf,@score);
			my $gene_type;

			foreach my $p (@{$gene_p->{tempexon}}) {
				push @exon,[$p->[0],$p->[1]];
				push @score,$p->[3];
				my $exon_len = abs($p->[0]-$p->[1])+1;
				my $phase = $p->[2];
				my ($orf_start,$orf_end);
				$orf_start = ($strand eq '+') ? ($p->[0] + $phase) : ($p->[0] - $phase);
				$orf_end = ($strand eq '+') ? ($p->[1] - ($exon_len-$phase)%3 ) : ($p->[1] + ($exon_len-$phase)%3 );
				push @orf,[$orf_start,$orf_end];
			}
			
			delete $gene_p->{tempexon};

			if (@exon > 1) {
				$gene_type = "multi-exon";
				$num_multi++;

			}elsif(@exon == 1){
				$gene_type = "sigle-exon";
				$num_single++;
			}
			
			$all{$seq_name}{$gene_name}{type}=$gene_type;
			$all{$seq_name}{$gene_name}{exon}=\@exon;
			$all{$seq_name}{$gene_name}{orf}=\@orf;
			$all{$seq_name}{$gene_name}{score}=\@score;
			

		}

	}
	
	##get sequence length
	get_seq_len();
}




#add "_TA" to the end of geneID
sub modify_geneID {
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			
			$seq_p->{$gene_name."-TA"} = $seq_p->{$gene_name};
			delete $seq_p->{$gene_name};
		}
	}
}


##make genome wide gene ID
sub final_name {
	my $mark = "000001";
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			my $final_name = $Final_name.$mark;
			$seq_p->{$final_name} = $seq_p->{$gene_name};
			delete $seq_p->{$gene_name};
			$mark++;
		}
	}
}

##creat *.table file
sub creat_table{
	open(OUT,">".$table_file) || die("fail to open $table_file\n");
	foreach my $seq_name (sort keys %all) {
		my $output;
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $type = $gene_p->{type};
			my $promoter = $gene_p->{promoter};
			my ($exon,$exon_num,$cds_size);
			foreach my $p (@{$gene_p->{exon}}) {
				$exon .= "$p->[0]-$p->[1],";
				$exon_num++;
				$cds_size += (abs($p->[1]-$p->[0])+1);
			}
			my $orf;
			foreach my $p (@{$gene_p->{orf}}) {
				$orf .= "$p->[0]-$p->[1],";
			}
			my $score;
			foreach my $value (@{$gene_p->{score}}) {
				$score .= "$value,";
			}
			my $polyA = $gene_p->{polyA};
			$output .= $gene_name."\t".$exon_num."\t".$cds_size."\t".$strand."\t".$seq_name."\t".$seq_len{$seq_name}."\t".$type."\t".$promoter."\t".$polyA."\t".$exon."\t".$orf."\t".$score."\n";
		}

		print OUT $output;
		
	}
	close OUT;
}



##creat psl file
sub creat_psl{
	my $output;
	#print Dumper \%all;
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			
			my @oldexon ;
			foreach my $p (@{$gene_p->{exon}}) {
				push @oldexon, [$p->[0],$p->[1]] ;
			}
			
			

			if ($strand eq '-') {
				@oldexon = reverse @oldexon;
				foreach my $p (@oldexon) {
					( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
				}
			}
			my @exon;
			foreach my $p (@oldexon) {
				push @exon,$p->[0],$p->[1];
			}

			
			my $block = @exon / 2; 
			my ($sizes,$qstarts,$tstarts,$match);
			for (my $i=0; $i<@exon; $i+=2) {
				#print "$exon[$i+1] , $exon[$i]\n";
				$match += $exon[$i+1] - $exon[$i] + 1;
				$sizes .= ( $exon[$i+1] - $exon[$i] + 1 ).",";
				$tstarts .= ( $exon[$i] - 1 ).",";
				$qstarts .= ( $match - ($exon[$i+1] - $exon[$i] + 1) ).",";
			}
			
			my $tstart = $exon[0] - 1;
			my $tend = $exon[(@exon - 1)];

			$output .= "$match\t0\t0\t0\t0\t0\t0\t0\t$strand\t$gene_name\t$match\t0\t$match\t$seq_name\t$seq_len{$seq_name}\t$tstart\t$tend\t$block\t$sizes\t$qstarts\t$tstarts\n";		
			#print "$match\t0\t0\t0\t0\t0\t0\t0\t$strand\t$gene_name\t$match\t0\t$match\t$seq_name\t$seq_len{$seq_name}\t$tstart\t$tend\t$block\t$sizes\t$qstarts\t$tstarts\n";		
		}
	}
	open OUT, ">$psl_file" || die "fail open $psl_file\n";
	print OUT $output;
	close OUT;
}



##creat *.gff file, support gff3
sub creat_gff{
	my $output = "##gff-version 3\n";
	open(OUT,">".$gff_file) || die("fail to open $gff_file\n");
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		$output .= "##sequence-region $seq_name 1 $seq_len{$seq_name}\n";
		foreach my $gene_name (sort keys %$seq_p) {
			
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			#my $type = $gene_p->{type};
			#$my $promoter = $gene_p->{promoter};
			#$my $polyA = $gene_p->{polyA};
			
			##对二维数组操作时要注意：
			## @exon = @{$gene_p->{exon}},只是在一维上新开了@exon,二维仍使用$gene_p->{exon}的内容。
			## 如果不想改变原二维数组内数值顺序，则必须在二维水平上新开@exon数组。
			my (@exon,@orf,@score);
			foreach my $p (@{$gene_p->{exon}}) {
				push @exon,[$p->[0],$p->[1]];
			}
			foreach my $p (@{$gene_p->{orf}}) {
				push @orf,[$p->[0],$p->[1]];
			}
			@score = @{$gene_p->{score}};
			
			my ($gene_start,$gene_end) = ($exon[0][0] < $exon[-1][1]) ? ($exon[0][0], $exon[-1][1]) : ($exon[-1][1], $exon[0][0]);
			
			my $gene_score = (exists $gene_p->{genescore}) ? $gene_p->{genescore} : '.';
			
			my $core_gene_name = $gene_name;
			$core_gene_name =~ s/-\w+$//;
			$output .= "$seq_name\t$Predict_prog\tgene\t$gene_start\t$gene_end\t.\t$strand\t.\tID=$core_gene_name;Name=$core_gene_name;\n";

			$output .= "$seq_name\t$Predict_prog\tmRNA\t$gene_start\t$gene_end\t$gene_score\t$strand\t.\tID=$gene_name;Name=$gene_name;Parent=$core_gene_name;\n";
			
#			my $mark=@exon;
#			$mark=~tr/[0-9]/0/;
#			$mark++;
#			for (my $i=0; $i<@exon; $i++) {
#				my $phase = ($exon[$i][0] - $orf[$i][0]) % 3;
#				my ($exon_start,$exon_end) = ($exon[$i][0] < $exon[$i][1]) ? ($exon[$i][0] , $exon[$i][1]) : ($exon[$i][1] , $exon[$i][0]);
#				my $exon_id = $gene_name."-E".$mark;
#				$output .= "$seq_name\t$Predict_prog\texon\t$exon_start\t$exon_end\t$score[$i]\t$strand\t.\tParent=$gene_name;\n";
#				$mark++;
#			}
			
			my $mark=@exon;
			$mark=~tr/[0-9]/0/;
			$mark++;
			for (my $i=0; $i<@exon; $i++) {
				my $phase = ($exon[$i][0] - $orf[$i][0]) % 3;
				my ($exon_start,$exon_end) = ($exon[$i][0] < $exon[$i][1]) ? ($exon[$i][0] , $exon[$i][1]) : ($exon[$i][1] , $exon[$i][0]);
				my $cds_id = $gene_name."-C".$mark;
				$output .= "$seq_name\t$Predict_prog\tCDS\t$exon_start\t$exon_end\t$score[$i]\t$strand\t$phase\tParent=$gene_name;\n";
				$mark++;
			}
		
		}
	}
	print OUT $output;
	close OUT;
}

##check cds on the sequence level, to see frameshift and internal stop codon.
sub check_cds {
	my ($multi_partial_num,$single_partial_num) = (0,0);
	open(IN, $sequence_file) || die ("can not open $sequence_file\n");
	$/=">"; <IN>; $/="\n";
	while (<IN>) {
		my $chr=$1 if(/^(\S+)/);
		$/=">";
		my $seq=<IN>;
		chomp $seq;
		$seq=~s/\s//g;
		$/="\n";

		my $seq_p = $all{$chr};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $type = $gene_p->{type};

			my @exon = @{$gene_p->{exon}};
			my $cds_str;
			foreach my $p (@exon) {
				my $str_len = abs($p->[0] - $p->[1]) + 1;
				my $str_start = ($p->[0] < $p->[1]) ?  $p->[0] : $p->[1];
				my $str = substr($seq,$str_start-1,$str_len);
				$str = Complement_Reverse($str) if($strand eq '-');
				$cds_str .= $str;
			}
			
			if( ! check_CDS($cds_str) ){
				$multi_partial_num++ if($type eq "multi-exon");
				$single_partial_num++ if($type eq "sigle-exon");
				$gene_p->{type} = "no-";
				delete $seq_p->{$gene_name};

			}
		}
	}
	print LOG "check cds model on the sequence:\n";
	print LOG "  remove wrong multi-exon genes $multi_partial_num\n";
	print LOG "  remove wrong single-exon genes $single_partial_num\n\n";

	$num_multi -= $multi_partial_num;
	$num_single -= $single_partial_num;
	$num_part += $multi_partial_num + $single_partial_num;

}


##filter Ns in CDS, default 10Ns
sub filter_Ns {
	open(IN, $sequence_file) || die ("can not open $sequence_file\n");
	$/=">"; <IN>; $/="\n";
	while (<IN>) {
		my $chr=$1 if(/^(\S+)/);
		$/=">";
		my $seq=<IN>;
		chomp $seq;
		$seq=~s/\s//g;
		$/="\n";

		my $seq_p = $all{$chr};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $type = $gene_p->{type};

			my @exon = @{$gene_p->{exon}};
			my $cds_str;
			foreach my $p (@exon) {
				my $str_len = abs($p->[0] - $p->[1]) + 1;
				my $str_start = ($p->[0] < $p->[1]) ?  $p->[0] : $p->[1];
				my $str = substr($seq,$str_start-1,$str_len);
				$str = Complement_Reverse($str) if($strand eq '-');
				$cds_str .= $str;
			}
			
			my $N_num = $cds_str =~ tr/NnXx//;
			if($N_num > 10){
				
				delete $seq_p->{$gene_name};

			}
		}
	}

}

#check whether a sequence accord with gene model
#############################################
sub check_CDS{
	my $seq=shift;
	my ($start,$end,$mid,$triple);
	$mid=1;
	my $len=length($seq);
	$triple=1 if($len%3 == 0);
	$start=1 if($seq=~/^ATG/);
	$end=1 if($seq=~/TAA$/ || $seq=~/TAG$/ || $seq=~/TGA$/);
	for (my $i=3; $i<$len-3; $i+=3) {
		my $codon=substr($seq,$i,3);
		$mid=0 if($codon eq 'TGA' || $codon eq 'TAG' || $codon eq 'TAA');
	}
	if ($start && $mid && $end && $triple ) {
		return 1;
	}else{
		return 0;
	}
}


##creat cds and pep file, also exon dna and exon pep file
sub creat_sequence{
	open OUT, ">$cds_file" || die "fail open $cds_file\n";
	open OUT2, ">$prot_file" || die "fail open $prot_file\n";
	open OUT3, ">$exon_dna_file" || die "fail open $exon_dna_file\n";
	open OUT4, ">$exon_prot_file" || die "fail open $exon_prot_file\n";
	open OUT5, ">$intron_dna_file" || die "fail open $intron_dna_file\n";

	open(IN, $sequence_file) || die ("can not open $sequence_file\n");
	$/=">"; <IN>; $/="\n";
	while (<IN>) {
		my $chr=$1 if(/^(\S+)/);
		$/=">";
		my $seq=<IN>;
		chomp $seq;
		$seq=~s/\s//g;
		$/="\n";
		
		my $output;
		my $output2;
		my $output3;
		my $output4;
		my $output5;

		my $seq_p = $all{$chr};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $genetype = $gene_p->{type};
			my $gene_name_core = $gene_name;
			$gene_name_core =~ s/-T\w$//; ##real gene name
			my $prot_name = $gene_name;
			$prot_name =~ s/-T(\w)$/-P\1/; ##protein name

			##make gene cds and protein
			my @exon = @{$gene_p->{exon}};
			my @orf = @{$gene_p->{orf}};
			my @score = @{$gene_p->{score}};
			my $exon_num = @exon;
			my ($gene_start,$gene_end) = ($exon[0][0] < $exon[-1][1]) ? ($exon[0][0], $exon[-1][1]) : ($exon[-1][1], $exon[0][0]);
			my $cds_str;
			foreach my $p (@exon) {
				
				##染色体从复制起点开始，不会破坏正常的基因结构，因而其实没必要采用环状形式
				##deal with glimmer/genemark circle DNA molecular
				if ($strand eq '+' && $exon[0][0] > $exon[0][1]) {
					my $first_half = substr($seq,$exon[0][0] - 1);
					my $second_half = substr($seq,0,$exon[0][1]);
					$cds_str = $first_half.$second_half;
					last;
				}
				##deal with glimmer/genemark circle DNA molecular
				if ($strand eq '-' && $exon[0][0] < $exon[0][1]) {
					my $first_half = substr($seq,$exon[0][1] - 1);
					my $second_half = substr($seq,0,$exon[0][0]);
					$cds_str = $first_half.$second_half;
					$cds_str = Complement_Reverse($cds_str);
					last;
				}

				
				my $str_len = abs($p->[0] - $p->[1]) + 1;
				my $str_start = ($p->[0] < $p->[1]) ?  $p->[0] : $p->[1];
				my $str = substr($seq,$str_start-1,$str_len);
				$str = Complement_Reverse($str) if($strand eq '-');
				$cds_str .= $str;
			}
			
			my $disp_str;
			Disp_seq(\$cds_str,\$disp_str);
			
			
			$output .= ">$gene_name  locus=$chr:$gene_start:$gene_end:$strand\n$disp_str";

			
			my $cds_phase = ($orf[0][0] ne 'none') ?  (abs($exon[0][0] - $orf[0][0]) % 3) : 0;
			my $prot_str = cds2aa($cds_str,$cds_phase);
			my $disp_str;
			Disp_seq(\$prot_str,\$disp_str);
			
			$output2 .= ">$prot_name  locus=$chr:$gene_start:$gene_end:$strand\n$disp_str";

			##make exon dna and protein
			my $mark=@exon;
			$mark=~tr/[0-9]/0/;
			$mark++;
			for(my $i=0; $i<@exon; $i++) {
				my $p = $exon[$i];
				my $str;
				my $str_len = abs($p->[0] - $p->[1]) + 1;
				my ($str_start,$str_end) = ($p->[0] < $p->[1]) ?  ($p->[0] , $p->[1]) : ($p->[1] , $p->[0]);
				$str = substr($seq,$str_start-1,$str_len);
				
				$str = Complement_Reverse($str) if($strand eq '-');
				my $disp_str;
				Disp_seq(\$str,\$disp_str);
				my $exon_dna_name = $gene_name.'-E'.$mark;
				my $exon_prot_name = $prot_name.'-E'.$mark;
				$output3 .= ">$exon_dna_name  locus=$chr:$str_start:$str_end:$strand\n$disp_str";
				
				my $exon_phase =($orf[$i][0] ne 'none') ?  (abs($exon[$i][0]-$orf[$i][0]) % 3) : 0;
				my $exon_prot = cds2aa($str,$exon_phase);
				my $disp_str;
				Disp_seq(\$exon_prot,\$disp_str);
				$output4 .= ">$exon_prot_name  locus=$chr:$str_start:$str_end:$strand\n$disp_str";
				
				$mark++;
			}

			##make intron dna file
			my $mark=@exon;
			$mark=~tr/[0-9]/0/;
			$mark++;
			for(my $i=0; $i<@exon-1; $i++) {

				my ($str_start,$str_end) = ($strand eq '+') ?  ($exon[$i][1]+1,$exon[$i+1][0]-1) : ($exon[$i+1][0]+1,$exon[$i][1]-1);
				
				my $str = substr($seq,$str_start-1,$str_end-$str_start+1);
				
				$str = Complement_Reverse($str) if($strand eq '-');
				my $disp_str;
				Disp_seq(\$str,\$disp_str);
				my $intron_dna_name = $gene_name.'-I'.$mark;
				$output5 .= ">$intron_dna_name  locus=$chr:$str_start:$str_end:$strand\n$disp_str";
				
				$mark++;
			}


		}
		
		print OUT $output;
		print OUT2 $output2;
		print OUT3 $output3;
		print OUT4 $output4;
		print OUT5 $output5;
	}

	close(IN);
	close OUT;
	close OUT2;
	close OUT3;
	close OUT4;
	close OUT5;
	`rm $exon_dna_file $exon_prot_file $intron_dna_file` if($Predict_prog eq 'glimmer' || $Predict_prog eq 'genemark');
}


##check whether there is redundance left
##use globle virables
sub check_redundance{
	my ($all_size,$pure_size,$redunt_size,$total_gene_len);
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		my (@pos1,@pos2);
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $gene_start = $gene_p->{exon}[0][0];
			my $gene_end = $gene_p->{exon}[-1][1];
			my $gene_len = abs($gene_end-$gene_start) + 1;
			$total_gene_len += $gene_len; ##note
			push @pos1, [$gene_start,$gene_end] if($strand eq '+');
			push @pos2, [$gene_end,$gene_start] if($strand eq '-');
			
		}
		
		my ($num1,$num2,$num3) = Conjoin_fragment(\@pos1);
		$all_size += $num1;
		$pure_size += $num2;
		$redunt_size += $num3;

		my ($num1,$num2,$num3) = Conjoin_fragment(\@pos2);
		$all_size += $num1;
		$pure_size += $num2;
		$redunt_size += $num3;
	}
	print LOG "\ncheck redundance on bp level:\n  $all_size (all) = $pure_size (pure) + $redunt_size (redunt)\n\n" if($Verbose);
}


##perfect gene set by removing imcomplete genes
##use globle virables
sub perfect_gene{
	my $partial_num;
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $type = $gene_p->{type};
			if($type =~ /^no-/){
				delete $seq_p->{$gene_name};
				$partial_num++;
			}
			
		}
	}
	print LOG "perfecting the gene set:\n  remove $partial_num incomplete genes\n\n" if($Verbose);

}

##perfect gene set by removing small genes
##use globle virables
sub cds_cutoff{
	foreach my $seq_name (sort keys %all) {
		my $seq_p = $all{$seq_name};
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $cds_size;
			foreach my $p (@{$gene_p->{exon}}) {
				$cds_size += abs($p->[1] - $p->[0]) + 1;
			}
			if($cds_size < $Mini_cds){
				delete $seq_p->{$gene_name};
				$small_cds_num++;
			}
			
		}
	}
	print LOG "Remove cds less than $Mini_cds bp\n remove $small_cds_num small cds genes\n\n" if($Verbose);

}

sub get_seq_len {
	##get original sequence length
	%seq_len = ();
	open(IN, $sequence_file) || die ("original sequence as second input file is needed for option --backcoor\n");
	$/=">"; <IN>; $/="\n";
	while (<IN>) {
		my $chr=$1 if(/^(\S+)/);
		$/=">";
		my $seq=<IN>;
		chomp $seq;
		$seq=~s/\s//g;
		$/="\n";
		$seq_len{$chr}=length($seq);
	}
	close(IN);
}

##backing coordinate onto origianal sequence
##use all global variables in this part
sub back_coor{
	
	get_seq_len();
	
	#print Dumper \%all;

	## convert fragment coordiante into origninal coordinate
	my $gene_frag_num = 0;
	foreach my $seq_name (sort keys %all) {
		
		next if($seq_name !~ /(\w+)_(\d+)_\d+$/); ## 
		
		my $seq_p = $all{$seq_name};
		my ($ori_seq_name,$ori_seq_start) =  ($1, $2) if($seq_name =~ /(\w+)_(\d+)_\d+$/);
		
		foreach my $gene_name (sort keys %$seq_p) {
			$gene_frag_num++;
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $type = $gene_p->{type};
			my $promoter = ($gene_p->{promoter} ne 'none') ? ($gene_p->{promoter} + $ori_seq_start -1) : $gene_p->{promoter};
			my @exon;
			foreach my $p (@{$gene_p->{exon}}) {
				push @exon,[$p->[0]+ $ori_seq_start -1, $p->[1] + $ori_seq_start -1];
			}
			my @orf;
			foreach my $p (@{$gene_p->{orf}}) {
				if ($p->[0] ne 'none') {
					push @orf,[$p->[0]+ $ori_seq_start -1, $p->[1] + $ori_seq_start -1];
				}else{
					push @orf,[$p->[0], $p->[1]];
				}
				
			}
			my @score = @{$gene_p->{score}};
			my $polyA = ($gene_p->{polyA} ne 'none') ? ($gene_p->{polyA} + $ori_seq_start -1) : $gene_p->{polyA};

			delete $all{$seq_name}{$gene_name};
			$all{$ori_seq_name}{$gene_name}{strand}=$strand;    
			$all{$ori_seq_name}{$gene_name}{type}=$type;        
			$all{$ori_seq_name}{$gene_name}{promoter}=$promoter;
			$all{$ori_seq_name}{$gene_name}{exon}=\@exon;       
			$all{$ori_seq_name}{$gene_name}{orf}=\@orf;         
			$all{$ori_seq_name}{$gene_name}{score}=\@score;     
			$all{$ori_seq_name}{$gene_name}{polyA}=$polyA;      
		}
		delete $all{$seq_name};
	}

	print LOG "Trace back coordinate to original sequence\n"   if($Verbose);
	print LOG "Remove redundence on the overlapped fragments:\n"   if($Verbose);
	
	#print Dumper \%all;
	
	##remove redundant genes predicted in the overlapped fragments
	##when two genes overlapped, remove the smaller one
	my $redunt_num = 0;
	foreach my $seq_name (sort keys %all) {
		
		##next if($seq_name !~ /([^_]+)_(\d+)_\d+$/); ## this is a bug line

		my $seq_p = $all{$seq_name};
		my (@pos1,@pos2);
		foreach my $gene_name (sort keys %$seq_p) {
			my $gene_p = $seq_p->{$gene_name};
			my $strand = $gene_p->{strand};
			my $gene_start = $gene_p->{exon}[0][0];
			my $gene_end = $gene_p->{exon}[-1][1];
			my $gene_len = abs($gene_end-$gene_start) + 1;
			push @pos1, [$gene_start,$gene_end,$gene_name,$seq_name] if($strand eq '+');
			push @pos2, [$gene_end,$gene_start,$gene_name,$seq_name] if($strand eq '-');
			
		}

		$redunt_num += purify_fragment(\@pos1);
		$redunt_num += purify_fragment(\@pos2);
		
	}
	my $total_gene_num = $gene_frag_num - $redunt_num;
	print LOG "  [all the genes] - [redundant genes] = [total genes]\n" if($Verbose);
	print LOG "  all the genes:    $gene_frag_num\n" if($Verbose);
	print LOG "  redundant genes:  $redunt_num\n" if($Verbose);
	print LOG "  total genes:      $total_gene_num\n" if($Verbose);
	
	
	##rename genes by sorted mark, and re-count gene numbers
	($num_multi,$num_single,$num_part) = (0,0,0);
	foreach my $seq_name (sort keys %all) {
		
		my $seq_p = $all{$seq_name};
		my $mark = keys %$seq_p;
		$mark=~tr/[0-9]/0/;
		$mark++;
		
		my %name_sort;
		foreach my $gene_name (sort keys %$seq_p) {
			if ($gene_name =~ /_(\d+)_\d+_(\d+)$/) {
				$name_sort{$1}{$2} = $gene_name;
			}
			my $type = $seq_p->{$gene_name}{type};
			if ($type eq 'multi-exon') {
				$num_multi++;
			}elsif ($type eq 'sigle-exon') {
				$num_single++;
			}else{
				$num_part++;
			}
		}

		foreach my $frag_start (sort {$a<=>$b} keys %name_sort) {
			foreach my $frag_id (sort keys %{$name_sort{$frag_start}}) {
				my $gene_name = $name_sort{$frag_start}{$frag_id};
				my $hash_p = $seq_p->{$gene_name};
				my $new_gene_name = $Name_tag.$Predict_prog."_".$seq_name."_".($mark++);
				delete $all{$seq_name}{$gene_name};
				$all{$seq_name}{$new_gene_name} = $hash_p;
			}
		}

	}

	#print Dumper \%all;
}


##parse the fgenesh result file, generate data structure,
##and output the protein sequences
####################################################
sub parse_GeneScan{
	my $str_p=shift;
	my $all_hp=shift;
	
	return if($$str_p =~ /NO EXONS\/GENES PREDICTED IN SEQUENCE/);

	my $cut_pos1 = index($$str_p,"\n\n 1.");
	my $cut_pos2 = index($$str_p,"Predicted peptide sequence(s):");
	my $head_part = substr($$str_p,0,$cut_pos1);
	my $gene_part = substr($$str_p,$cut_pos1,$cut_pos2-$cut_pos1);
	#my $prot_part = substr($$str_p,$cut_pos2);
	$$str_p="";

	my ($seq_name,$seq_leng) = ($1,$2) if($head_part=~/Sequence (\S+) : (\d+) bp/);
	$head_part = "";
	
	return if($seq_leng < $Mini_seq);

	$seq_len{$seq_name} = $seq_leng;

	$gene_part=~s/^\s+//g;
	$gene_part=~s/\s+$//g;
	my @genes=split(/\n\n/,$gene_part);
	$gene_part = "";

	my $mark=@genes;
	$mark=~tr/[0-9]/0/;
	$mark++;

	foreach (@genes) {
		my ($gene_name, $strand, $type, @exon, @orf, @score, $promoter, $polyA);
		
		if (/^\s*(\d+)\.\d+\s+\w+\s+([+-])\s+/) {
			$gene_name = $Name_tag.$Predict_prog."_".$seq_name."_".($mark++);
			$strand = $2;
		}
		if (/Init/ && /Term/) {
			$type = "multi-exon";
			$num_multi++;
		}elsif(/Sngl/){
			$type = "sigle-exon";
			$num_single++;
		}elsif(!/Init/ && /Term/){
			$type = "no-first";
			$num_part++;
		}elsif(/Init/ && !/Term/){
			$type = "no-last";
			$num_part++;
		}elsif(!/Init/ && !/Term/){
			$type = "no-first-last";
			$num_part++;
		}
		
		while (/(Init|Intr|Term|Sngl)\s+[+-]\s+(\d+)\s+(\d+)\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+)/g) {
			if ($strand eq '+') {
				push @exon,[$2,$3];
			}else{
				push @exon,[$3,$2];
			}
			
			push @score,$4;
		}
		


		##caculate orf
		my $leave = 0;
		foreach my $p (@exon) {
			my $fdel = (3-$leave)%3;
			my $start = $p->[0] + $fdel;
			$leave = ( $p->[1] - $p->[0] + 1 - $fdel ) % 3;
			my $end = $p->[1] - $leave;
			if ($end - $start + 1 >= 3 ) { ##at least one codon
				push @orf,[$start,$end];
			}else{
				push @orf, ["none","none"];
			}
			
		}

		if ($strand eq '-') {
			@exon = reverse @exon;
			@orf = reverse @orf;
			@score = reverse @score;
			foreach my $p (@exon) {
				( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
			}
			foreach my $p (@orf) {
				( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
			}
		}
		
		if (/Prom\s+[+-]\s+(\d+)/){
			$promoter = $1;
		}else{
			$promoter = "none";
		}

		if (/PlyA\s+[+-]\s+(\d+)/) {
			$polyA = $1;
		}else{
			$polyA = "none";
		}
		
		
		$all_hp->{$seq_name}{$gene_name}{strand}=$strand;
		$all_hp->{$seq_name}{$gene_name}{type}=$type;
		$all_hp->{$seq_name}{$gene_name}{promoter}=$promoter;
		$all_hp->{$seq_name}{$gene_name}{exon}=\@exon;
		$all_hp->{$seq_name}{$gene_name}{orf}=\@orf;
		$all_hp->{$seq_name}{$gene_name}{score}=\@score;
		$all_hp->{$seq_name}{$gene_name}{polyA}=$polyA;
		

	}

}
####################################################



##parse the fgenesh result file, generate data structure,
##and output the protein sequences
####################################################
sub parse_fgenesh{
	my $str_p=shift;
	my $all_hp=shift;
	
	return if($$str_p =~ /no reliable predictions/);

	my $cut_pos1 = index($$str_p,"\n\n   1 ");
	my $cut_pos2 = index($$str_p,"Predicted protein(s):");
	my $head_part = substr($$str_p,0,$cut_pos1);
	my $gene_part = substr($$str_p,$cut_pos1,$cut_pos2-$cut_pos1);
	#my $prot_part = substr($$str_p,$cut_pos2);
	$$str_p="";

	
	my $seq_name = $1 if($head_part=~/Seq name:\s+(\S+)\s+/);
	my $seq_leng = $1 if($head_part=~/Length of sequence:\s+(\d+)\s+/);
	$head_part = "";
	
	return if($seq_leng < $Mini_seq);

	$seq_len{$seq_name} = $seq_leng;

	$gene_part=~s/^\s+//g;
	$gene_part=~s/\s+$//g;
	my @genes=split(/\n\n/,$gene_part);
	$gene_part = "";

	my $mark=@genes;
	$mark=~tr/[0-9]/0/;
	$mark++;

	foreach (@genes) {
		my ($gene_name, $strand, $type, @exon, @orf, @score, $promoter, $polyA);
		
		if (/^\s*(\d+)\s+([+-])\s+/) {
			$gene_name = $Name_tag.$Predict_prog."_".$seq_name."_".($mark++);
			$strand = $2;
		}
		if (/CDSf/ && /CDSl/) {
			$type = "multi-exon";
			$num_multi++;
		}elsif(/CDSo/){
			$type = "sigle-exon";
			$num_single++;
		}elsif(!/CDSf/ && /CDSl/){
			$type = "no-first";
			$num_part++;
		}elsif(/CDSf/ && !/CDSl/){
			$type = "no-last";
			$num_part++;
		}elsif(!/CDSf/ && !/CDSl/){
			$type = "no-first-last";
			$num_part++;
		}

		while (/CDS\w\s+(\d+)\s+-\s+(\d+)\s+(\S+)\s+(\d+)\s+-\s+(\d+)/g) {
			next if ($1 == $2 || $4 > $5); ##fgenesh结果中有些bug,如：   2 +    2 CDSi      8275 -      8275   -5.36      8276 -      8275      0
			push @exon,[$1,$2];
			push @score,$3;
			if ($5-$4+1 >= 3) { ##at least one codon
				push @orf,[$4,$5];
			}else{
				push @orf,['none','none'];
			}
			
		}
		if ($strand eq '-') {
			@exon = reverse @exon;
			@orf = reverse @orf;
			@score = reverse @score;
			foreach my $p (@exon) {
				( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
			}
			foreach my $p (@orf) {
				( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
			}
		}
		
		if (/TSS\s+(\d+)/){
			$promoter = $1;
		}else{
			$promoter = "none";
		}

		if (/PolA\s+(\d+)/) {
			$polyA = $1;
		}else{
			$polyA = "none";
		}
		
		
		$all_hp->{$seq_name}{$gene_name}{strand}=$strand;
		$all_hp->{$seq_name}{$gene_name}{type}=$type;
		$all_hp->{$seq_name}{$gene_name}{promoter}=$promoter;
		$all_hp->{$seq_name}{$gene_name}{exon}=\@exon;
		$all_hp->{$seq_name}{$gene_name}{orf}=\@orf;
		$all_hp->{$seq_name}{$gene_name}{score}=\@score;
		$all_hp->{$seq_name}{$gene_name}{polyA}=$polyA;

	}

}
####################################################


##parse the BGF result file, generate data structure,
##and output the protein sequences
####################################################
sub parse_BGF{
	my $str_p=shift;
	my $all_hp=shift;
	
	return if($$str_p =~ /no reliable gene/);

	$$str_p=~s/The input sequence has unknown character or format error!//g;
	$$str_p=~s/\s+$//;

	my $cut_pos1 = index($$str_p,"\n\n    1 ");
	my $cut_pos2 = index($$str_p,"Predicted protein(s):");
	my $head_part = substr($$str_p,0,$cut_pos1);
	my $gene_part = substr($$str_p,$cut_pos1,$cut_pos2-$cut_pos1);
	#my $prot_part = substr($$str_p,$cut_pos2);
	$$str_p="";

	my $seq_name = $1 if($head_part=~/Sequence\s+:\s+(\S+)\s+/);
	my $seq_leng = $1 if($head_part=~/Length\s+:\s+(\d+)\s+/);
	$head_part = "";
	
	return if($seq_leng < $Mini_seq);

	$seq_len{$seq_name} = $seq_leng;

	$gene_part=~s/^\s+//g;
	$gene_part=~s/\s+$//g;
	my @genes=split(/\n\n/,$gene_part);
	$gene_part = "";

	my $mark=@genes;
	$mark=~tr/[0-9]/0/;
	$mark++;

	foreach (@genes) {
		my ($gene_name, $strand, $type, @exon,  @orf, @score, $promoter, $polyA);
		
		if (/^\s*(\d+)\s+([+-])\s+/) {
			$gene_name = $Name_tag.$Predict_prog."_".$seq_name."_".($mark++);
			$strand = $2;
		}
		
		if (/Init/ && /Term/) {
			$type = "multi-exon";
			$num_multi++;
		}elsif(/Sngl/){
			$type = "sigle-exon";
			$num_single++;
		}elsif(!/Init/ && /Term/){
			$type = "no-first";
			$num_part++;
		}elsif(/Init/ && !/Term/){
			$type = "no-last";
			$num_part++;
		}elsif(!/Init/ && !/Term/){
			$type = "no-first-last";
			$num_part++;
		}

		while (/(Init|Intr|Term|Sngl)\s+(\d+)\s+-\s+(\d+)\s+(\d+)\s+-\s+(\d+)\s+(\S+)/g) {
			push @exon,[$2,$3];
			push @score,$6;
			if ($5-$4+1 >= 3) { ##at least one codon
				push @orf,[$4,$5];
			}else{
				push @orf,['none','none'];
			}
		}
		
		if ($strand eq '-') {
			@exon = reverse @exon;
			@orf = reverse @orf;
			@score = reverse @score;
			foreach my $p (@exon) {
				( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
			}
			foreach my $p (@orf) {
				( $p->[0],$p->[1] ) = ( $p->[1],$p->[0] ) ;
			}
		}
		
		if (/Prom\s+(\d+)/){
			$promoter = $1;
		}else{
			$promoter = "none";
		}

		if (/PolA\s+(\d+)/) {
			$polyA = $1;
		}else{
			$polyA = "none";
		}

		$all_hp->{$seq_name}{$gene_name}{strand}=$strand;
		$all_hp->{$seq_name}{$gene_name}{type}=$type;
		$all_hp->{$seq_name}{$gene_name}{promoter}=$promoter;
		$all_hp->{$seq_name}{$gene_name}{exon}=\@exon;
		$all_hp->{$seq_name}{$gene_name}{orf}=\@orf;
		$all_hp->{$seq_name}{$gene_name}{score}=\@score;
		$all_hp->{$seq_name}{$gene_name}{polyA}=$polyA;
	}

}
####################################################


#usage: disp_seq(\$string,$num_line);
#############################################
sub Disp_seq{
	my $seq_pp=shift;
	my $disp_pp=shift;
	my $num_line=(@_) ? shift : 50;
	
	my $len=length($$seq_pp);
	for (my $i=0; $i<$len; $i+=$num_line) {
		my $sub=substr($$seq_pp,$i,$num_line);
		$$disp_pp .= $sub."\n";
	}
	$$disp_pp = "\n" if(! $$disp_pp);

}
#############################################


#############################################
sub Complement_Reverse{
	my $seq=shift;
	$seq=~tr/AGCTagct/TCGAtcga/;
	$seq=reverse($seq);
	return $seq;

}
#############################################


## convert cds to protein
sub cds2aa{
	my $seq = shift;
	my $phase = shift || 0;
	die "phase is $phase, it should be 0 1 or 2" if($phase != 0 && $phase != 1 && $phase != 2);

	$seq =~ s/\s//g;
	$seq = uc($seq);
	
	my $len = length($seq);
	
	my $prot;
	for (my $i=$phase; $i<$len; $i+=3) {
		my $codon = substr($seq,$i,3);
		last if(length($codon) < 3);
		$prot .= (exists $Translate{$codon}) ? $Translate{$codon} : 'X';
	}
	$prot =~ s/U$//;
	return $prot;
}


##conjoin the overlapped fragments, and caculate the redundant size
##usage: conjoin_fragment(\@pos);
##		 my ($all_size,$pure_size,$redunt_size) = conjoin_fragment(\@pos);
sub Conjoin_fragment{
	my $pos_p = shift; ##point to the two dimension input array
	my $new_p = [];         ##point to the two demension result array
	
	my ($all_size, $pure_size, $redunt_size) = (0,0,0); 
	
	return (0,0,0) unless(@$pos_p);

	foreach my $p (@$pos_p) {
			($p->[0],$p->[1]) = ($p->[0] <= $p->[1]) ? ($p->[0],$p->[1]) : ($p->[1],$p->[0]);
			$all_size += abs($p->[0] - $p->[1]) + 1;
	}
	
	@$pos_p = sort {$a->[0] <=>$b->[0]} @$pos_p;
	push @$new_p, (shift @$pos_p);
	
	foreach my $p (@$pos_p) {
			if ( ($p->[0] - $new_p->[-1][1]) <= 0 ) { # conjoin
					if ($new_p->[-1][1] < $p->[1]) {
							$new_p->[-1][1] = $p->[1]; 
					}
					
			}else{  ## not conjoin
					push @$new_p, $p;
			}
	}
	@$pos_p = @$new_p;

	foreach my $p (@$pos_p) {
			$pure_size += abs($p->[0] - $p->[1]) + 1;
	}
	
	$redunt_size = $all_size - $pure_size;
	return ($all_size,$pure_size,$redunt_size);
}

##remove redundant genes, keep the larger one when two gene overlapped.
sub purify_fragment{
	my $pos_p = shift; ##point to the two dimension input array
	my $new_p = ();         ##point to the two demension result array
	
	my ($all_size, $pure_size, $redunt_size,$redunt_num) = (0,0,0,0); 
	
	return 0 unless(@$pos_p);

	foreach my $p (@$pos_p) {
		($p->[0],$p->[1]) = ($p->[0] <= $p->[1]) ? ($p->[0],$p->[1]) : ($p->[1],$p->[0]);
		$all_size += abs($p->[0] - $p->[1]) + 1;
	}
	@$pos_p = sort {$a->[0] <=> $b->[0]} @$pos_p;
	push @$new_p, (shift @$pos_p);
	
	foreach my $p (@$pos_p) {
		if ( ($p->[0] - $new_p->[-1][1]) <= 0 ) { # remove
			if ( ($new_p->[-1][1] - $new_p->[-1][0]) < ($p->[1]-$p->[0]) ) {
				delete $all{$new_p->[-1][3]}{$new_p->[-1][2]};
				pop  @$new_p;
				push @$new_p,$p;
			}else{
				delete $all{$p->[3]}{$p->[2]};
			}
			$redunt_num++;
		}else{  ## not remove
			push @$new_p,$p;
		}
	}
	@$pos_p = @$new_p;

	foreach my $p (@$pos_p) {
		$pure_size += abs($p->[0] - $p->[1]) + 1;
	}
	
	$redunt_size = $all_size - $pure_size;
	return $redunt_num;
}





__END__

print Dumper \%all;

$VAR1 = {
          'silk_chr2' => {
                           'shezhen001702-TA' => {
                                                   'promoter' => '2447680',
                                                   'strand' => '-',
                                                   'polyA' => '2442476',
                                                   'score' => [
                                                                '4.38',
                                                                '1.04',
                                                                '1.87',
                                                                '10.01',
                                                                '10.69',
                                                                '4.41'
                                                              ],
                                                   'exon' => [
                                                               [
                                                                 2447378,
                                                                 2447306
                                                               ],
                                                               [
                                                                 2445825,
                                                                 2445676
                                                               ],
                                                               [
                                                                 2445195,
                                                                 2445022
                                                               ],
                                                               [
                                                                 2443693,
                                                                 2443545
                                                               ],
                                                               [
                                                                 2443141,
                                                                 2442920
                                                               ],
                                                               [
                                                                 2442720,
                                                                 2442538
                                                               ]
                                                             ],
                                                   'type' => 'multi-exon',
                                                   'orf' => [
                                                              [
                                                                '2447378',
                                                                '2447307'
                                                              ],
                                                              [
                                                                '2445823',
                                                                '2445677'
                                                              ],
                                                              [
                                                                '2445193',
                                                                '2445023'
                                                              ],
                                                              [
                                                                '2443691',
                                                                '2443545'
                                                              ],
                                                              [
                                                                '2443141',
                                                                '2442920'
                                                              ],
                                                              [
                                                                '2442720',
                                                                '2442538'
                                                              ]
                                                            ]
                                                 },
                           
                           'shezhen001482-TA' => {
                                                   'promoter' => '609181',
                                                   'strand' => '+',
                                                   'polyA' => '618284',
                                                   'score' => [
                                                                '3.55',
                                                                '6.06',
                                                                '11.48',
                                                                '5.25',
                                                                '10.98',
                                                                '6.53'
                                                              ],
                                                   'exon' => [
                                                               [
                                                                 610476,
                                                                 610660
                                                               ],
                                                               [
                                                                 611766,
                                                                 611903
                                                               ],
                                                               [
                                                                 612249,
                                                                 613625
                                                               ],
                                                               [
                                                                 615904,
                                                                 616063
                                                               ],
                                                               [
                                                                 617063,
                                                                 617301
                                                               ],
                                                               [
                                                                 617790,
                                                                 618144
                                                               ]
                                                             ],
                                                   'type' => 'multi-exon',
                                                   'orf' => [
                                                              [
                                                                '610476',
                                                                '610658'
                                                              ],
                                                              [
                                                                '611767',
                                                                '611901'
                                                              ],
                                                              [
                                                                '612250',
                                                                '613623'
                                                              ],
                                                              [
                                                                '615905',
                                                                '616063'
                                                              ],
                                                              [
                                                                '617063',
                                                                '617299'
                                                              ],
                                                              [
                                                                '617791',
                                                                '618144'
                                                              ]
                                                            ]
                                                 },
