use Getopt::Long;
use Pod::Usage;
use File::Basename;
use Graph::Undirected;
use Data::Dumper;

GetOptions (\%opt,"classify:s","fpc:s","project:s","help");


my $help=<<USAGE;
perl $0 --classify --fpc 
--classify: classify file generated by classifyclone.pl
--fpc: fpc file from omap
USAGE

if ($opt{help} or keys %opt < 1){
   print "$help\n";
   exit ();
}
my $maxdist=300000;
my $title=$1 if ($opt{classify}=~/(.*)\.classify/);
$opt{project} ||=$title;
my @candidates=getdiscordantclone($opt{classify});
#foreach my $c (@candidates){
#   print "$c->{'clone_name'}\t$c->{'clone_chromosome'}\t$c->{'clone_start'}\t$c->{'clone_stop'}\n";
#}
###generate pairwise number for cluster
my @pairs=make_pair_combinations($#candidates);
my $g =Graph::Undirected->new;
for my $pair (@pairs){
    my ($c1, $c2) = map {$candidates[$_]} @$pair;
    #print "$pair->[0]\t$pair->[1]\n";
    ### check if the two clones were overlap on chromosoe
    #print "$c1->{'clone_start'}\t$c1->{'clone_stop'}\t$c2->{'clone_start'}\t$c2->{'clone_stop'}\n";
    next if ($c1->{'clone_stop'} <= $c2->{'clone_start'} or $c1->{'clone_start'} >= $c2->{'clone_stop'}); 
    my %bes1 = (
         chromosome => $c1->{'bes1_chromosome'},
         start      => $c1->{'bes1_chr_start'},
         stop       => $c1->{'bes1_chr_stop'},
    );
    my %bes2 = (
         chromosome => $c1->{'bes2_chromosome'},
         start      => $c1->{'bes2_chr_start'},
         stop       => $c1->{'bes2_chr_stop'},
    );
    my %bes3 = (
         chromosome => $c2->{'bes1_chromosome'},
         start      => $c2->{'bes1_chr_start'},
         stop       => $c2->{'bes1_chr_stop'},
    );
    my %bes4 = (
         chromosome => $c2->{'bes2_chromosome'},
         start      => $c2->{'bes2_chr_start'},
         stop       => $c2->{'bes2_chr_stop'},
    );
    ###record bes position of two clone cluster
    my @pos;
    if ($c1->{'clone_chromosome'} eq $c2->{'clone_chromosome'}){
        push @pos, {    
             x1 => $bes1{'start'},
             y1 => $bes2{'stop'},
             x2 => $bes3{'start'},
             y2 => $bes4{'stop'},
        };
    }
    next unless @pos;
    my @distance =map {abs($_->{'x2'}-$_->{'x1'}) + abs($_->{'y2'}-$_->{'y1'})} @pos;
    
    foreach my $d (@distance){
       if ($d <= 2*$maxdist){
          $g->add_edge(@$pair);
       }
    }
}
###
my @cluster=$g->connected_components();
open OUT, ">$opt{project}.cluster" or die "$!";
for(my $i=0;$i<@cluster;$i++){
    if (@{$cluster[$i]} > 0){
        my $size=@{$cluster[$i]};
        my $nodes=join(",",@{$cluster[$i]});
        print OUT ">ID=$i\tNumber=$size\tNodes=$nodes\n";
        foreach my $node (@{$cluster[$i]}){
           print OUT "$candidates[$node]->{'clone_name'}\t$candidates[$node]->{'clone_status'}\t$candidates[$node]->{'bes1_chromosome'}\t$candidates[$node]->{'bes1_chr_start'}\t$candidates[$node]->{'bes1_chr_stop'}\t$candidates[$node]->{'bes2_chromosome'}\t$candidates[$node]->{'bes2_chr_start'}\t$candidates[$node]->{'bes2_chr_stop'}\n";
        }
    }
}
close OUT;
###
=pod
####make edge into cluster
my @edges=$g->edges;
my %bins;
my $last_bin_no = 1;
foreach (@edges) {
    my $v1=$_->[0];
    my $v2=$_->[1];
    my $bin_no;
    if (exists $bins{$v1}){
       $bin_no=$bins{$v1};
    }elsif(exists $bins{$v2}){
       $bin_no=$bins{$v2};
    }else{
       $last_bin_no++;
       $bin_no=$last_bin_no;
    }
    #my $bin_no = $bins{ $v1 } || $bins{ $v2 } || $last_bin_no++;
    #print "Bin_no:$bin_no\tV1:$v1\tV2:$v2\n";
    for my $v ( $v1, $v2 ) {
        $bins{ $v } = $bin_no;
    }
}

my %clusters;
while ( my ( $node, $bin ) = each %bins ) {
      push @{ $clusters{ $bin } }, $node;
}
####
my $no_clusters;
for my $cluster_no ( sort {$a <=> $b} keys %clusters ) {
    my $size=@{$clusters{$cluster_no}};
    my $nodes=join(",",@{$clusters{$cluster_no}});
    print ">ID=$cluster_no\tNumber=$size\tNodes=$nodes\n";
    foreach $node (@{$clusters{$cluster_no}}){
        print "$candidates[$node]->{'clone_name'}\t$candidates[$node]->{'clone_status'}\t$candidates[$node]->{'bes1_chromosome'}\t$candidates[$node]->{'bes1_chr_start'}\t$candidates[$node]->{'bes1_chr_stop'}\t$candidates[$node]->{'bes2_chromosome'}\t$candidates[$node]->{'bes2_chr_start'}\t$candidates[$node]->{'bes2_chr_stop'}\n";
    }
    $no_clusters++;
}
print "Number of cluster: $no_clusters\n";
=cut

#######
sub getdiscordantclone
{
my ($file)=@_;
$/=">";
my @candidate;
open IN, "$file" or die "$!";
while(<IN>){
    chomp $_;
    next if (length $_ < 2);
    my @line=split("\n",$_);
    my $head=shift @line;
    $head=$1 if ($head=~/\>(\w+)/);
    my $type=shift @line;
    my @unit=split("\t",$type);
    if ($unit[2] == 0){##discordant, but not in diff chromosome or single bes hit
       my %hash;
       my @unit1=split("\t",$line[0]);
       my @unit2=split("\t",$line[1]);
       ###bes1
       my $bes1chr=$unit1[4];
       my $bes1strand=$unit1[7] > $unit1[6] ? 1 : 0;
       my $bes1start =$unit1[7] > $unit1[6] ? $unit1[6] : $unit1[7];
       my $bes1stop  =$unit1[7] > $unit1[6] ? $unit1[7] : $unit1[6];
       ###bes2
       my $bes2chr=$unit2[4];
       my $bes2strand=$unit2[7] > $unit2[6] ? 1 : 0;
       my $bes2start=$unit2[7] > $unit2[6] ? $unit2[6] : $unit2[7]; 
       my $bes2stop  =$unit2[7] > $unit2[6] ? $unit2[7] : $unit2[6];
       ### clone start and end on chromosome
       #print "$head\t$bes1start,$bes1stop,$bes2start,$bes2stop\n";
       my @pos=sort {$a <=> $b} ($bes1start,$bes1stop,$bes2start,$bes2stop);
       #print "$head\t$pos[0]\t$pos[$#pos]\n";
       ###hash
       my %hash=(
          "bes1_chromosome" => $bes1chr,
          "bes1_strand"     => $bes1strand,
          "bes1_chr_start"  => $bes1start,
          "bes1_chr_stop"   => $bes1stop,
          "bes2_chromosome" => $bes2chr,
          "bes2_strand"     => $bes2strand,
          "bes2_chr_start"  => $bes2start,
          "bes2_chr_stop"   => $bes2stop,
          "clone_name"      => $head,
          "clone_status"    => $unit[1],
          "clone_start"     => $pos[0],
          "clone_stop"      => $pos[$#pos],
          "clone_chromosome"=> $bes1chr
       );  
       push (@candidate,\%hash);
    }
}
close IN;
$/="\n";
return @candidate;
}


# ----------------------------------------------------
sub make_pair_combinations {
    my $limit = shift;
    my @return;
    for my $i ( 0 .. $limit ) {
        for my $j ( $i .. $limit ) {
            next if $i == $j;
            push @return, [ $i, $j ];
        }
    }
    return @return;
}

# ----------------------------------------------------

sub delete_clone_clusters {

}

# ----------------------------------------------------
sub get_clone_cluster_id {

}

